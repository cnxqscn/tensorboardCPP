// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorboardX/proto/layout.proto

#ifndef PROTOBUF_tensorboardX_2fproto_2flayout_2eproto__INCLUDED
#define PROTOBUF_tensorboardX_2fproto_2flayout_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace tensorboardX {
class Category;
class CategoryDefaultTypeInternal;
extern CategoryDefaultTypeInternal _Category_default_instance_;
class Chart;
class ChartDefaultTypeInternal;
extern ChartDefaultTypeInternal _Chart_default_instance_;
class Layout;
class LayoutDefaultTypeInternal;
extern LayoutDefaultTypeInternal _Layout_default_instance_;
class MarginChartContent;
class MarginChartContentDefaultTypeInternal;
extern MarginChartContentDefaultTypeInternal _MarginChartContent_default_instance_;
class MarginChartContent_Series;
class MarginChartContent_SeriesDefaultTypeInternal;
extern MarginChartContent_SeriesDefaultTypeInternal _MarginChartContent_Series_default_instance_;
class MultilineChartContent;
class MultilineChartContentDefaultTypeInternal;
extern MultilineChartContentDefaultTypeInternal _MultilineChartContent_default_instance_;
}  // namespace tensorboardX

namespace tensorboardX {

namespace protobuf_tensorboardX_2fproto_2flayout_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_tensorboardX_2fproto_2flayout_2eproto

// ===================================================================

class Chart : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorboardX.Chart) */ {
 public:
  Chart();
  virtual ~Chart();

  Chart(const Chart& from);

  inline Chart& operator=(const Chart& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Chart& default_instance();

  enum ContentCase {
    kMultiline = 2,
    kMargin = 3,
    CONTENT_NOT_SET = 0,
  };

  static inline const Chart* internal_default_instance() {
    return reinterpret_cast<const Chart*>(
               &_Chart_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Chart* other);

  // implements Message ----------------------------------------------

  inline Chart* New() const PROTOBUF_FINAL { return New(NULL); }

  Chart* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Chart& from);
  void MergeFrom(const Chart& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Chart* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string title = 1;
  void clear_title();
  static const int kTitleFieldNumber = 1;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // .tensorboardX.MultilineChartContent multiline = 2;
  bool has_multiline() const;
  void clear_multiline();
  static const int kMultilineFieldNumber = 2;
  const ::tensorboardX::MultilineChartContent& multiline() const;
  ::tensorboardX::MultilineChartContent* mutable_multiline();
  ::tensorboardX::MultilineChartContent* release_multiline();
  void set_allocated_multiline(::tensorboardX::MultilineChartContent* multiline);

  // .tensorboardX.MarginChartContent margin = 3;
  bool has_margin() const;
  void clear_margin();
  static const int kMarginFieldNumber = 3;
  const ::tensorboardX::MarginChartContent& margin() const;
  ::tensorboardX::MarginChartContent* mutable_margin();
  ::tensorboardX::MarginChartContent* release_margin();
  void set_allocated_margin(::tensorboardX::MarginChartContent* margin);

  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:tensorboardX.Chart)
 private:
  void set_has_multiline();
  void set_has_margin();

  inline bool has_content() const;
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  union ContentUnion {
    ContentUnion() {}
    ::tensorboardX::MultilineChartContent* multiline_;
    ::tensorboardX::MarginChartContent* margin_;
  } content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_tensorboardX_2fproto_2flayout_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultilineChartContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorboardX.MultilineChartContent) */ {
 public:
  MultilineChartContent();
  virtual ~MultilineChartContent();

  MultilineChartContent(const MultilineChartContent& from);

  inline MultilineChartContent& operator=(const MultilineChartContent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultilineChartContent& default_instance();

  static inline const MultilineChartContent* internal_default_instance() {
    return reinterpret_cast<const MultilineChartContent*>(
               &_MultilineChartContent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MultilineChartContent* other);

  // implements Message ----------------------------------------------

  inline MultilineChartContent* New() const PROTOBUF_FINAL { return New(NULL); }

  MultilineChartContent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MultilineChartContent& from);
  void MergeFrom(const MultilineChartContent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MultilineChartContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tag = 1;
  int tag_size() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  const ::std::string& tag(int index) const;
  ::std::string* mutable_tag(int index);
  void set_tag(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tag(int index, ::std::string&& value);
  #endif
  void set_tag(int index, const char* value);
  void set_tag(int index, const char* value, size_t size);
  ::std::string* add_tag();
  void add_tag(const ::std::string& value);
  #if LANG_CXX11
  void add_tag(::std::string&& value);
  #endif
  void add_tag(const char* value);
  void add_tag(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tag() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tag();

  // @@protoc_insertion_point(class_scope:tensorboardX.MultilineChartContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tag_;
  mutable int _cached_size_;
  friend struct protobuf_tensorboardX_2fproto_2flayout_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarginChartContent_Series : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorboardX.MarginChartContent.Series) */ {
 public:
  MarginChartContent_Series();
  virtual ~MarginChartContent_Series();

  MarginChartContent_Series(const MarginChartContent_Series& from);

  inline MarginChartContent_Series& operator=(const MarginChartContent_Series& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarginChartContent_Series& default_instance();

  static inline const MarginChartContent_Series* internal_default_instance() {
    return reinterpret_cast<const MarginChartContent_Series*>(
               &_MarginChartContent_Series_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MarginChartContent_Series* other);

  // implements Message ----------------------------------------------

  inline MarginChartContent_Series* New() const PROTOBUF_FINAL { return New(NULL); }

  MarginChartContent_Series* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MarginChartContent_Series& from);
  void MergeFrom(const MarginChartContent_Series& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MarginChartContent_Series* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string lower = 2;
  void clear_lower();
  static const int kLowerFieldNumber = 2;
  const ::std::string& lower() const;
  void set_lower(const ::std::string& value);
  #if LANG_CXX11
  void set_lower(::std::string&& value);
  #endif
  void set_lower(const char* value);
  void set_lower(const char* value, size_t size);
  ::std::string* mutable_lower();
  ::std::string* release_lower();
  void set_allocated_lower(::std::string* lower);

  // string upper = 3;
  void clear_upper();
  static const int kUpperFieldNumber = 3;
  const ::std::string& upper() const;
  void set_upper(const ::std::string& value);
  #if LANG_CXX11
  void set_upper(::std::string&& value);
  #endif
  void set_upper(const char* value);
  void set_upper(const char* value, size_t size);
  ::std::string* mutable_upper();
  ::std::string* release_upper();
  void set_allocated_upper(::std::string* upper);

  // @@protoc_insertion_point(class_scope:tensorboardX.MarginChartContent.Series)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr lower_;
  ::google::protobuf::internal::ArenaStringPtr upper_;
  mutable int _cached_size_;
  friend struct protobuf_tensorboardX_2fproto_2flayout_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarginChartContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorboardX.MarginChartContent) */ {
 public:
  MarginChartContent();
  virtual ~MarginChartContent();

  MarginChartContent(const MarginChartContent& from);

  inline MarginChartContent& operator=(const MarginChartContent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarginChartContent& default_instance();

  static inline const MarginChartContent* internal_default_instance() {
    return reinterpret_cast<const MarginChartContent*>(
               &_MarginChartContent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MarginChartContent* other);

  // implements Message ----------------------------------------------

  inline MarginChartContent* New() const PROTOBUF_FINAL { return New(NULL); }

  MarginChartContent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MarginChartContent& from);
  void MergeFrom(const MarginChartContent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MarginChartContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MarginChartContent_Series Series;

  // accessors -------------------------------------------------------

  // repeated .tensorboardX.MarginChartContent.Series series = 1;
  int series_size() const;
  void clear_series();
  static const int kSeriesFieldNumber = 1;
  const ::tensorboardX::MarginChartContent_Series& series(int index) const;
  ::tensorboardX::MarginChartContent_Series* mutable_series(int index);
  ::tensorboardX::MarginChartContent_Series* add_series();
  ::google::protobuf::RepeatedPtrField< ::tensorboardX::MarginChartContent_Series >*
      mutable_series();
  const ::google::protobuf::RepeatedPtrField< ::tensorboardX::MarginChartContent_Series >&
      series() const;

  // @@protoc_insertion_point(class_scope:tensorboardX.MarginChartContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorboardX::MarginChartContent_Series > series_;
  mutable int _cached_size_;
  friend struct protobuf_tensorboardX_2fproto_2flayout_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Category : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorboardX.Category) */ {
 public:
  Category();
  virtual ~Category();

  Category(const Category& from);

  inline Category& operator=(const Category& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Category& default_instance();

  static inline const Category* internal_default_instance() {
    return reinterpret_cast<const Category*>(
               &_Category_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Category* other);

  // implements Message ----------------------------------------------

  inline Category* New() const PROTOBUF_FINAL { return New(NULL); }

  Category* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Category& from);
  void MergeFrom(const Category& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Category* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorboardX.Chart chart = 2;
  int chart_size() const;
  void clear_chart();
  static const int kChartFieldNumber = 2;
  const ::tensorboardX::Chart& chart(int index) const;
  ::tensorboardX::Chart* mutable_chart(int index);
  ::tensorboardX::Chart* add_chart();
  ::google::protobuf::RepeatedPtrField< ::tensorboardX::Chart >*
      mutable_chart();
  const ::google::protobuf::RepeatedPtrField< ::tensorboardX::Chart >&
      chart() const;

  // string title = 1;
  void clear_title();
  static const int kTitleFieldNumber = 1;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // bool closed = 3;
  void clear_closed();
  static const int kClosedFieldNumber = 3;
  bool closed() const;
  void set_closed(bool value);

  // @@protoc_insertion_point(class_scope:tensorboardX.Category)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorboardX::Chart > chart_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  bool closed_;
  mutable int _cached_size_;
  friend struct protobuf_tensorboardX_2fproto_2flayout_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Layout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorboardX.Layout) */ {
 public:
  Layout();
  virtual ~Layout();

  Layout(const Layout& from);

  inline Layout& operator=(const Layout& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Layout& default_instance();

  static inline const Layout* internal_default_instance() {
    return reinterpret_cast<const Layout*>(
               &_Layout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Layout* other);

  // implements Message ----------------------------------------------

  inline Layout* New() const PROTOBUF_FINAL { return New(NULL); }

  Layout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Layout& from);
  void MergeFrom(const Layout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Layout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorboardX.Category category = 2;
  int category_size() const;
  void clear_category();
  static const int kCategoryFieldNumber = 2;
  const ::tensorboardX::Category& category(int index) const;
  ::tensorboardX::Category* mutable_category(int index);
  ::tensorboardX::Category* add_category();
  ::google::protobuf::RepeatedPtrField< ::tensorboardX::Category >*
      mutable_category();
  const ::google::protobuf::RepeatedPtrField< ::tensorboardX::Category >&
      category() const;

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorboardX.Layout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorboardX::Category > category_;
  ::google::protobuf::int32 version_;
  mutable int _cached_size_;
  friend struct protobuf_tensorboardX_2fproto_2flayout_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Chart

// string title = 1;
inline void Chart::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chart::title() const {
  // @@protoc_insertion_point(field_get:tensorboardX.Chart.title)
  return title_.GetNoArena();
}
inline void Chart::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorboardX.Chart.title)
}
#if LANG_CXX11
inline void Chart::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorboardX.Chart.title)
}
#endif
inline void Chart::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorboardX.Chart.title)
}
inline void Chart::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorboardX.Chart.title)
}
inline ::std::string* Chart::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:tensorboardX.Chart.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chart::release_title() {
  // @@protoc_insertion_point(field_release:tensorboardX.Chart.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chart::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:tensorboardX.Chart.title)
}

// .tensorboardX.MultilineChartContent multiline = 2;
inline bool Chart::has_multiline() const {
  return content_case() == kMultiline;
}
inline void Chart::set_has_multiline() {
  _oneof_case_[0] = kMultiline;
}
inline void Chart::clear_multiline() {
  if (has_multiline()) {
    delete content_.multiline_;
    clear_has_content();
  }
}
inline  const ::tensorboardX::MultilineChartContent& Chart::multiline() const {
  // @@protoc_insertion_point(field_get:tensorboardX.Chart.multiline)
  return has_multiline()
      ? *content_.multiline_
      : ::tensorboardX::MultilineChartContent::default_instance();
}
inline ::tensorboardX::MultilineChartContent* Chart::mutable_multiline() {
  if (!has_multiline()) {
    clear_content();
    set_has_multiline();
    content_.multiline_ = new ::tensorboardX::MultilineChartContent;
  }
  // @@protoc_insertion_point(field_mutable:tensorboardX.Chart.multiline)
  return content_.multiline_;
}
inline ::tensorboardX::MultilineChartContent* Chart::release_multiline() {
  // @@protoc_insertion_point(field_release:tensorboardX.Chart.multiline)
  if (has_multiline()) {
    clear_has_content();
    ::tensorboardX::MultilineChartContent* temp = content_.multiline_;
    content_.multiline_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Chart::set_allocated_multiline(::tensorboardX::MultilineChartContent* multiline) {
  clear_content();
  if (multiline) {
    set_has_multiline();
    content_.multiline_ = multiline;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorboardX.Chart.multiline)
}

// .tensorboardX.MarginChartContent margin = 3;
inline bool Chart::has_margin() const {
  return content_case() == kMargin;
}
inline void Chart::set_has_margin() {
  _oneof_case_[0] = kMargin;
}
inline void Chart::clear_margin() {
  if (has_margin()) {
    delete content_.margin_;
    clear_has_content();
  }
}
inline  const ::tensorboardX::MarginChartContent& Chart::margin() const {
  // @@protoc_insertion_point(field_get:tensorboardX.Chart.margin)
  return has_margin()
      ? *content_.margin_
      : ::tensorboardX::MarginChartContent::default_instance();
}
inline ::tensorboardX::MarginChartContent* Chart::mutable_margin() {
  if (!has_margin()) {
    clear_content();
    set_has_margin();
    content_.margin_ = new ::tensorboardX::MarginChartContent;
  }
  // @@protoc_insertion_point(field_mutable:tensorboardX.Chart.margin)
  return content_.margin_;
}
inline ::tensorboardX::MarginChartContent* Chart::release_margin() {
  // @@protoc_insertion_point(field_release:tensorboardX.Chart.margin)
  if (has_margin()) {
    clear_has_content();
    ::tensorboardX::MarginChartContent* temp = content_.margin_;
    content_.margin_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Chart::set_allocated_margin(::tensorboardX::MarginChartContent* margin) {
  clear_content();
  if (margin) {
    set_has_margin();
    content_.margin_ = margin;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorboardX.Chart.margin)
}

inline bool Chart::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Chart::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Chart::ContentCase Chart::content_case() const {
  return Chart::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MultilineChartContent

// repeated string tag = 1;
inline int MultilineChartContent::tag_size() const {
  return tag_.size();
}
inline void MultilineChartContent::clear_tag() {
  tag_.Clear();
}
inline const ::std::string& MultilineChartContent::tag(int index) const {
  // @@protoc_insertion_point(field_get:tensorboardX.MultilineChartContent.tag)
  return tag_.Get(index);
}
inline ::std::string* MultilineChartContent::mutable_tag(int index) {
  // @@protoc_insertion_point(field_mutable:tensorboardX.MultilineChartContent.tag)
  return tag_.Mutable(index);
}
inline void MultilineChartContent::set_tag(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorboardX.MultilineChartContent.tag)
  tag_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MultilineChartContent::set_tag(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorboardX.MultilineChartContent.tag)
  tag_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MultilineChartContent::set_tag(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorboardX.MultilineChartContent.tag)
}
inline void MultilineChartContent::set_tag(int index, const char* value, size_t size) {
  tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorboardX.MultilineChartContent.tag)
}
inline ::std::string* MultilineChartContent::add_tag() {
  // @@protoc_insertion_point(field_add_mutable:tensorboardX.MultilineChartContent.tag)
  return tag_.Add();
}
inline void MultilineChartContent::add_tag(const ::std::string& value) {
  tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorboardX.MultilineChartContent.tag)
}
#if LANG_CXX11
inline void MultilineChartContent::add_tag(::std::string&& value) {
  tag_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorboardX.MultilineChartContent.tag)
}
#endif
inline void MultilineChartContent::add_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorboardX.MultilineChartContent.tag)
}
inline void MultilineChartContent::add_tag(const char* value, size_t size) {
  tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorboardX.MultilineChartContent.tag)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MultilineChartContent::tag() const {
  // @@protoc_insertion_point(field_list:tensorboardX.MultilineChartContent.tag)
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MultilineChartContent::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:tensorboardX.MultilineChartContent.tag)
  return &tag_;
}

// -------------------------------------------------------------------

// MarginChartContent_Series

// string value = 1;
inline void MarginChartContent_Series::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MarginChartContent_Series::value() const {
  // @@protoc_insertion_point(field_get:tensorboardX.MarginChartContent.Series.value)
  return value_.GetNoArena();
}
inline void MarginChartContent_Series::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorboardX.MarginChartContent.Series.value)
}
#if LANG_CXX11
inline void MarginChartContent_Series::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorboardX.MarginChartContent.Series.value)
}
#endif
inline void MarginChartContent_Series::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorboardX.MarginChartContent.Series.value)
}
inline void MarginChartContent_Series::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorboardX.MarginChartContent.Series.value)
}
inline ::std::string* MarginChartContent_Series::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:tensorboardX.MarginChartContent.Series.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarginChartContent_Series::release_value() {
  // @@protoc_insertion_point(field_release:tensorboardX.MarginChartContent.Series.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarginChartContent_Series::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:tensorboardX.MarginChartContent.Series.value)
}

// string lower = 2;
inline void MarginChartContent_Series::clear_lower() {
  lower_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MarginChartContent_Series::lower() const {
  // @@protoc_insertion_point(field_get:tensorboardX.MarginChartContent.Series.lower)
  return lower_.GetNoArena();
}
inline void MarginChartContent_Series::set_lower(const ::std::string& value) {
  
  lower_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorboardX.MarginChartContent.Series.lower)
}
#if LANG_CXX11
inline void MarginChartContent_Series::set_lower(::std::string&& value) {
  
  lower_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorboardX.MarginChartContent.Series.lower)
}
#endif
inline void MarginChartContent_Series::set_lower(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lower_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorboardX.MarginChartContent.Series.lower)
}
inline void MarginChartContent_Series::set_lower(const char* value, size_t size) {
  
  lower_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorboardX.MarginChartContent.Series.lower)
}
inline ::std::string* MarginChartContent_Series::mutable_lower() {
  
  // @@protoc_insertion_point(field_mutable:tensorboardX.MarginChartContent.Series.lower)
  return lower_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarginChartContent_Series::release_lower() {
  // @@protoc_insertion_point(field_release:tensorboardX.MarginChartContent.Series.lower)
  
  return lower_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarginChartContent_Series::set_allocated_lower(::std::string* lower) {
  if (lower != NULL) {
    
  } else {
    
  }
  lower_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lower);
  // @@protoc_insertion_point(field_set_allocated:tensorboardX.MarginChartContent.Series.lower)
}

// string upper = 3;
inline void MarginChartContent_Series::clear_upper() {
  upper_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MarginChartContent_Series::upper() const {
  // @@protoc_insertion_point(field_get:tensorboardX.MarginChartContent.Series.upper)
  return upper_.GetNoArena();
}
inline void MarginChartContent_Series::set_upper(const ::std::string& value) {
  
  upper_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorboardX.MarginChartContent.Series.upper)
}
#if LANG_CXX11
inline void MarginChartContent_Series::set_upper(::std::string&& value) {
  
  upper_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorboardX.MarginChartContent.Series.upper)
}
#endif
inline void MarginChartContent_Series::set_upper(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  upper_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorboardX.MarginChartContent.Series.upper)
}
inline void MarginChartContent_Series::set_upper(const char* value, size_t size) {
  
  upper_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorboardX.MarginChartContent.Series.upper)
}
inline ::std::string* MarginChartContent_Series::mutable_upper() {
  
  // @@protoc_insertion_point(field_mutable:tensorboardX.MarginChartContent.Series.upper)
  return upper_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarginChartContent_Series::release_upper() {
  // @@protoc_insertion_point(field_release:tensorboardX.MarginChartContent.Series.upper)
  
  return upper_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarginChartContent_Series::set_allocated_upper(::std::string* upper) {
  if (upper != NULL) {
    
  } else {
    
  }
  upper_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), upper);
  // @@protoc_insertion_point(field_set_allocated:tensorboardX.MarginChartContent.Series.upper)
}

// -------------------------------------------------------------------

// MarginChartContent

// repeated .tensorboardX.MarginChartContent.Series series = 1;
inline int MarginChartContent::series_size() const {
  return series_.size();
}
inline void MarginChartContent::clear_series() {
  series_.Clear();
}
inline const ::tensorboardX::MarginChartContent_Series& MarginChartContent::series(int index) const {
  // @@protoc_insertion_point(field_get:tensorboardX.MarginChartContent.series)
  return series_.Get(index);
}
inline ::tensorboardX::MarginChartContent_Series* MarginChartContent::mutable_series(int index) {
  // @@protoc_insertion_point(field_mutable:tensorboardX.MarginChartContent.series)
  return series_.Mutable(index);
}
inline ::tensorboardX::MarginChartContent_Series* MarginChartContent::add_series() {
  // @@protoc_insertion_point(field_add:tensorboardX.MarginChartContent.series)
  return series_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorboardX::MarginChartContent_Series >*
MarginChartContent::mutable_series() {
  // @@protoc_insertion_point(field_mutable_list:tensorboardX.MarginChartContent.series)
  return &series_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorboardX::MarginChartContent_Series >&
MarginChartContent::series() const {
  // @@protoc_insertion_point(field_list:tensorboardX.MarginChartContent.series)
  return series_;
}

// -------------------------------------------------------------------

// Category

// string title = 1;
inline void Category::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Category::title() const {
  // @@protoc_insertion_point(field_get:tensorboardX.Category.title)
  return title_.GetNoArena();
}
inline void Category::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorboardX.Category.title)
}
#if LANG_CXX11
inline void Category::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorboardX.Category.title)
}
#endif
inline void Category::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorboardX.Category.title)
}
inline void Category::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorboardX.Category.title)
}
inline ::std::string* Category::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:tensorboardX.Category.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Category::release_title() {
  // @@protoc_insertion_point(field_release:tensorboardX.Category.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Category::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:tensorboardX.Category.title)
}

// repeated .tensorboardX.Chart chart = 2;
inline int Category::chart_size() const {
  return chart_.size();
}
inline void Category::clear_chart() {
  chart_.Clear();
}
inline const ::tensorboardX::Chart& Category::chart(int index) const {
  // @@protoc_insertion_point(field_get:tensorboardX.Category.chart)
  return chart_.Get(index);
}
inline ::tensorboardX::Chart* Category::mutable_chart(int index) {
  // @@protoc_insertion_point(field_mutable:tensorboardX.Category.chart)
  return chart_.Mutable(index);
}
inline ::tensorboardX::Chart* Category::add_chart() {
  // @@protoc_insertion_point(field_add:tensorboardX.Category.chart)
  return chart_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorboardX::Chart >*
Category::mutable_chart() {
  // @@protoc_insertion_point(field_mutable_list:tensorboardX.Category.chart)
  return &chart_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorboardX::Chart >&
Category::chart() const {
  // @@protoc_insertion_point(field_list:tensorboardX.Category.chart)
  return chart_;
}

// bool closed = 3;
inline void Category::clear_closed() {
  closed_ = false;
}
inline bool Category::closed() const {
  // @@protoc_insertion_point(field_get:tensorboardX.Category.closed)
  return closed_;
}
inline void Category::set_closed(bool value) {
  
  closed_ = value;
  // @@protoc_insertion_point(field_set:tensorboardX.Category.closed)
}

// -------------------------------------------------------------------

// Layout

// int32 version = 1;
inline void Layout::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 Layout::version() const {
  // @@protoc_insertion_point(field_get:tensorboardX.Layout.version)
  return version_;
}
inline void Layout::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:tensorboardX.Layout.version)
}

// repeated .tensorboardX.Category category = 2;
inline int Layout::category_size() const {
  return category_.size();
}
inline void Layout::clear_category() {
  category_.Clear();
}
inline const ::tensorboardX::Category& Layout::category(int index) const {
  // @@protoc_insertion_point(field_get:tensorboardX.Layout.category)
  return category_.Get(index);
}
inline ::tensorboardX::Category* Layout::mutable_category(int index) {
  // @@protoc_insertion_point(field_mutable:tensorboardX.Layout.category)
  return category_.Mutable(index);
}
inline ::tensorboardX::Category* Layout::add_category() {
  // @@protoc_insertion_point(field_add:tensorboardX.Layout.category)
  return category_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorboardX::Category >*
Layout::mutable_category() {
  // @@protoc_insertion_point(field_mutable_list:tensorboardX.Layout.category)
  return &category_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorboardX::Category >&
Layout::category() const {
  // @@protoc_insertion_point(field_list:tensorboardX.Layout.category)
  return category_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace tensorboardX

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorboardX_2fproto_2flayout_2eproto__INCLUDED
